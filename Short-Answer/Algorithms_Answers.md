#### Please add your answers to the **_Analysis of Algorithms_** exercises here.

## Exercise I

a) O(n) because the loop shows n _ n _ n and a increases n \* n make the solution iterate o(n) times

b) o(n^2) becuase there are 2 checks for n and is in a for loop of n which i think makes o(n^2)

c) o(n) because even though theres recursion n stays a constant

## Exercise II

this represents our building
h break
g break
f break
e notbreak
d notbreak
c notbreak
b notbreak
a notbreak

```
def eggSaftey(n):
    if n < f:
        return 'egg will not break'
    else:
        return 'egg will break'
```

o(n) because n doesnt change as we go through the algorithm
